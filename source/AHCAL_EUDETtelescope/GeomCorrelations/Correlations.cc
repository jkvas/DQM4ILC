/// \file Correlations.cc
/*
 *-------------------------------------------------------------
 * AHCALRawModule.cc source template automatically modified from 
 * CaloHitModule  generated by a class generator
 * by A. Irles, DESY, 23 March 2016
 *--------------------------------------------------------------
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "Correlations.h"
// to handle and acces to the elements in the LCIO generic Object

// -- std headers
#include <ctime>
#include <cstdlib>
#include <limits>
#include <map>
#include <vector>

//#ifndef USELCIO
//#define USELCIO
#include "EVENT/TrackerData.h"
#include "EVENT/LCGenericObject.h"
#include "EVENT/LCCollection.h"
#include "EVENT/LCEvent.h"
#include "EVENT/LCIO.h"
#include "UTIL/CellIDDecoder.h"
#include "UTIL/LCTOOLS.h"
//#endif

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMCoreTool.h"
#include "dqm4hep/DQMRun.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMEvent.h"
#include "dqm4hep/DQMQualityTest.h"
#include "dqm4hep/DQMModuleApi.h"
#include "dqm4hep/DQMPlugin.h"

// -- root headers
#include "TRandom.h"
#include "TString.h" // Added by Tom for TString handling

//using namespace lcio;

namespace dqm4hep
{
  // module plugin declaration
  DQM_PLUGIN_DECL( Correlations , "TelescopeAHCALCorrelations" )

  //-------------------------------------------------------------------------------------------------

  Correlations::Correlations() :
  DQMAnalysisModule()
  {
    setDetectorName("NO DETECTOR");
    setVersion(1, 0, 0);
  }

  //-------------------------------------------------------------------------------------------------

  Correlations::~Correlations()
  {
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Correlations::readSettings(const TiXmlHandle xmlHandle)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- readSettings()" );

    // ####################################################################################################################################
    // AHCAL section

    std::string m_geometryFilename = "";

    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
                                                                                                             "GeometryFilename", m_geometryFilename));

    dqm4hep::TiXmlDocument m_geometryFile(m_geometryFilename);
    
    if( ! m_geometryFile.LoadFile() )
      return dqm4hep::STATUS_CODE_FAILURE;

    const dqm4hep::TiXmlHandle xmlGeometryFileHandle(&m_geometryFile);

    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, Correlations::buildGeometryMap(xmlGeometryFileHandle));

    //---------------------------------------------------------------------
    //Correlation time plots 
    m_pLDA_TLU_Offset = NULL;
    m_pTriggerID = NULL;
    m_pTimeCycle = NULL;
    m_pCorrelatedBXID = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "LDA_TLU_Offset", m_pLDA_TLU_Offset));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TriggerID", m_pTriggerID));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "TimeCycle", m_pTimeCycle));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "CorrelatedBXID", m_pCorrelatedBXID));

    //---------------------------------------------------------------------
    //Correlation X with AHCAL-I (ADC > 30)
    m_pX_I_300_l01 = NULL;
    m_pX_I_300_l02 = NULL;
    m_pX_I_300_l03 = NULL;
    m_pX_I_300_l04 = NULL;
    m_pX_I_300_l05 = NULL;
    m_pX_I_300_l06 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_I_300_l01", m_pX_I_300_l01));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_I_300_l02", m_pX_I_300_l02));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_I_300_l03", m_pX_I_300_l03));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_I_300_l04", m_pX_I_300_l04));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_I_300_l05", m_pX_I_300_l05));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_I_300_l06", m_pX_I_300_l06));

  
    //--------------------------------------------------------------------
    //Correlation Y with AHCAL-I (ADC > 30)
    m_pY_I_300_l01 = NULL;
    m_pY_I_300_l02 = NULL;
    m_pY_I_300_l03 = NULL;
    m_pY_I_300_l04 = NULL;
    m_pY_I_300_l05 = NULL;
    m_pY_I_300_l06 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_I_300_l01", m_pY_I_300_l01));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_I_300_l02", m_pY_I_300_l02));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_I_300_l03", m_pY_I_300_l03));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_I_300_l04", m_pY_I_300_l04));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_I_300_l05", m_pY_I_300_l05));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_I_300_l06", m_pY_I_300_l06));

    //---------------------------------------------------------------------
    //Correlation X with AHCAL-J (ADC > 30)
    m_pX_J_300_l01 = NULL;
    m_pX_J_300_l02 = NULL;
    m_pX_J_300_l03 = NULL;
    m_pX_J_300_l04 = NULL;
    m_pX_J_300_l05 = NULL;
    m_pX_J_300_l06 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_J_300_l01", m_pX_J_300_l01));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_J_300_l02", m_pX_J_300_l02));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_J_300_l03", m_pX_J_300_l03));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_J_300_l04", m_pX_J_300_l04));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_J_300_l05", m_pX_J_300_l05));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_J_300_l06", m_pX_J_300_l06));

  
    //--------------------------------------------------------------------
    //Correlation Y with AHCAL-J (ADC > 30)
    m_pY_J_300_l01 = NULL;
    m_pY_J_300_l02 = NULL;
    m_pY_J_300_l03 = NULL;
    m_pY_J_300_l04 = NULL;
    m_pY_J_300_l05 = NULL;
    m_pY_J_300_l06 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_J_300_l01", m_pY_J_300_l01));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_J_300_l02", m_pY_J_300_l02));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_J_300_l03", m_pY_J_300_l03));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_J_300_l04", m_pY_J_300_l04));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_J_300_l05", m_pY_J_300_l05));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_J_300_l06", m_pY_J_300_l06));


    //---------------------------------------------------------------------
    //Correlation X with AHCAL-I (ADC > 30) for non correlated (in time) hits
    m_pX_noC_I_300_l01 = NULL;
    m_pX_noC_I_300_l02 = NULL;
    m_pX_noC_I_300_l03 = NULL;
    m_pX_noC_I_300_l04 = NULL;
    m_pX_noC_I_300_l05 = NULL;
    m_pX_noC_I_300_l06 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_noC_I_300_l01", m_pX_noC_I_300_l01));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_noC_I_300_l02", m_pX_noC_I_300_l02));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_noC_I_300_l03", m_pX_noC_I_300_l03));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_noC_I_300_l04", m_pX_noC_I_300_l04));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_noC_I_300_l05", m_pX_noC_I_300_l05));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_noC_I_300_l06", m_pX_noC_I_300_l06));

  
    //--------------------------------------------------------------------
    //Correlation Y with AHCAL-I (ADC > 30) for non correlated (in time) hits
    m_pY_noC_I_300_l01 = NULL;
    m_pY_noC_I_300_l02 = NULL;
    m_pY_noC_I_300_l03 = NULL;
    m_pY_noC_I_300_l04 = NULL;
    m_pY_noC_I_300_l05 = NULL;
    m_pY_noC_I_300_l06 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_noC_I_300_l01", m_pY_noC_I_300_l01));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_noC_I_300_l02", m_pY_noC_I_300_l02));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_noC_I_300_l03", m_pY_noC_I_300_l03));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_noC_I_300_l04", m_pY_noC_I_300_l04));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_noC_I_300_l05", m_pY_noC_I_300_l05));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_noC_I_300_l06", m_pY_noC_I_300_l06));

    //---------------------------------------------------------------------
    //Correlation X with AHCAL-J (ADC > 30) for non correlated (in time) hits
    m_pX_noC_J_300_l01 = NULL;
    m_pX_noC_J_300_l02 = NULL;
    m_pX_noC_J_300_l03 = NULL;
    m_pX_noC_J_300_l04 = NULL;
    m_pX_noC_J_300_l05 = NULL;
    m_pX_noC_J_300_l06 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_noC_J_300_l01", m_pX_noC_J_300_l01));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_noC_J_300_l02", m_pX_noC_J_300_l02));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_noC_J_300_l03", m_pX_noC_J_300_l03));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_noC_J_300_l04", m_pX_noC_J_300_l04));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_noC_J_300_l05", m_pX_noC_J_300_l05));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "X_noC_J_300_l06", m_pX_noC_J_300_l06));

  
    //--------------------------------------------------------------------
    //Correlation Y with AHCAL-J (ADC > 30) for non correlated (in time) hits
    m_pY_noC_J_300_l01 = NULL;
    m_pY_noC_J_300_l02 = NULL;
    m_pY_noC_J_300_l03 = NULL;
    m_pY_noC_J_300_l04 = NULL;
    m_pY_noC_J_300_l05 = NULL;
    m_pY_noC_J_300_l06 = NULL;
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_noC_J_300_l01", m_pY_noC_J_300_l01));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_noC_J_300_l02", m_pY_noC_J_300_l02));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_noC_J_300_l03", m_pY_noC_J_300_l03));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_noC_J_300_l04", m_pY_noC_J_300_l04));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_noC_J_300_l05", m_pY_noC_J_300_l05));
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMXmlHelper::bookMonitorElement(this, xmlHandle, "Y_noC_J_300_l06", m_pY_noC_J_300_l06));

   
  

    // ####################################################################################################################################
    // EUDET TELESCOPE SECTION
    // ----------------------------
    // Hot pixels Map
    // ----------------------------

    std::string m_hotpixelsFilename = "";

    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,
                                                                                                             "HotPixelsFilename", m_hotpixelsFilename));

    dqm4hep::TiXmlDocument m_hotpixelsFile(m_hotpixelsFilename);
    
    if( ! m_hotpixelsFile.LoadFile() )
      return dqm4hep::STATUS_CODE_FAILURE;

    const dqm4hep::TiXmlHandle xmlGeometryTelescopeFileHandle(&m_hotpixelsFile);

    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, Correlations::buildHotPixelsMap(xmlGeometryTelescopeFileHandle));


    // ####################################################################################################################################
    //-----------------------------------------------------
    m_dumpEvent = false;
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,"DumpEvent", m_dumpEvent));

    m_requireDaqQuality = false; 
    RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, DQMXmlHelper::readParameterValue(xmlHandle,"RequireDaqQuality", m_requireDaqQuality));

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Correlations::initModule()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- init()" );

    // print directory structure of monitor element storage in console
    DQMModuleApi::cd(this);
    DQMModuleApi::ls(this, true);

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Correlations::endModule()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- end()" );
    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Correlations::processEvent(DQMEvent *pEvent)
  {
    int EventCntIndex = 1;
    int BxIDIndex = 1;
    int EvtNrIndex = 2;
    int ChipIDIndex = 3;
    int NChannelsIndex = 4;
    int TDCFirstChannelIndex = 5;
    int ADCFirstChannelIndex = TDCFirstChannelIndex+36;

    EVENT::LCEvent *pLCEvent = pEvent->getEvent<EVENT::LCEvent>();

    int evtnumber = pLCEvent->getEventNumber();

    if(!pLCEvent)
      return STATUS_CODE_FAILURE;

    if(m_dumpEvent)
      UTIL::LCTOOLS::dumpEvent(pLCEvent);


    const std::vector<std::string> *pCollectionNames = pLCEvent->getCollectionNames();

    std::vector<int> X_sensor0;
    std::vector<int> Y_sensor0;

    int allcollections=0;

    for(std::vector<std::string>::const_iterator colIter = pCollectionNames->begin(); colIter != pCollectionNames->end() ; ++colIter)
      {
	const std::string &collectionName(*colIter);
	if(collectionName=="EUDAQDataLDATS" || collectionName=="EUDAQDataScCAL" || collectionName=="zsdata_m26" ) 
	  allcollections++;
      }

    if(allcollections != 3)  {
      std::cout<<"DEBUG: not all collections present. only "<<allcollections<<" Found."<<std::endl;
      return STATUS_CODE_SUCCESS;
    }   else {
      EVENT::LCCollection *pLCCollection = pLCEvent->getCollection("EUDAQDataLDATS");

      // #####################################################################################################################
      // Timestamp section

      const EVENT::LCGenericObject *const pTimeStampsRaw = 
	dynamic_cast<const EVENT::LCGenericObject *const>(pLCCollection->getElementAt(0));

      unsigned int start_TS_low = (unsigned int)pTimeStampsRaw->getIntVal(0);
      unsigned int start_TS_high = (unsigned int)pTimeStampsRaw->getIntVal(1);
      unsigned long long int TimeStamp_start = 0;
      TimeStamp_start = ( (unsigned long long int)start_TS_high<<32 | start_TS_low )*25./1000.;
	
      unsigned int stop_TS_low = (unsigned int)pTimeStampsRaw->getIntVal(2);
      unsigned int stop_TS_high = (unsigned int)pTimeStampsRaw->getIntVal(3);
      unsigned long long int TimeStamp_stop = 0;
      TimeStamp_stop = ( (unsigned long long int)stop_TS_high<<32 | stop_TS_low )*25./1000.;
	
      unsigned int trig_TS_low = (unsigned int)pTimeStampsRaw->getIntVal(4);
      unsigned int trig_TS_high = (unsigned int)pTimeStampsRaw->getIntVal(5);
      unsigned long long int TimeStamp_trig = 0;  
      TimeStamp_trig = ( (unsigned long long int)trig_TS_high<<32 | trig_TS_low )*25./1000.;
  
      unsigned long long int TimeStamp_tlu = pLCEvent->getTimeStamp();
	
      Int_t Npoints = m_pLDA_TLU_Offset->get<TGraph>()->GetN();
      m_pLDA_TLU_Offset->get<TGraph>()->SetPoint(Npoints,TimeStamp_trig,TimeStamp_tlu);
 
      Npoints = m_pTriggerID->get<TGraph>()->GetN();
      m_pTriggerID->get<TGraph>()->SetPoint(Npoints,TimeStamp_trig,TimeStamp_trig-TimeStamp_start);

      Npoints = m_pTimeCycle->get<TGraph>()->GetN();
      m_pTimeCycle->get<TGraph>()->SetPoint(Npoints,TimeStamp_trig,TimeStamp_stop-TimeStamp_start);

     
      // #####################################################################################################################
      // TELESCOPE section
      pLCCollection = pLCEvent->getCollection("zsdata_m26");

      UTIL::CellIDDecoder<EVENT::TrackerData> cellIdDecoder(pLCCollection);
      
      const int nElements = pLCCollection->getNumberOfElements();
      
      const EVENT::TrackerData *const pEUDETtelescopeHitMaps_1 = dynamic_cast<const EVENT::TrackerData *const>(pLCCollection->getElementAt(0));
      
      
      for(int i=0; i< pEUDETtelescopeHitMaps_1->getChargeValues().size(); i+=4) {
	double x_1 = pEUDETtelescopeHitMaps_1->getChargeValues().at(i);
	double y_1 = pEUDETtelescopeHitMaps_1->getChargeValues().at(i+1);
	bool hotpix=false;
	
	for (std::map<int,int>::iterator it=hotpixelsMap[0].begin(); it!=hotpixelsMap[0].end(); ++it) 
	  if( x_1 == it->first && y_1==it->second) hotpix=true;
	
	if(hotpix==false) {
	  X_sensor0.push_back(x_1);
	  Y_sensor0.push_back(y_1);
	}      
      }
      
      // #####################################################################################################################
      // AHCAL section
      pLCCollection = pLCEvent->getCollection("EUDAQDataScCAL");
	
    
      int daqquality = pLCCollection->getParameters().getIntVal("DAQquality");
      if( (!m_requireDaqQuality) | (daqquality==1) ) {
	    
	const int nElements = pLCCollection->getNumberOfElements();

	for(int e=0 ; e<nElements ; e++)
	  {
	    const EVENT::LCGenericObject *const pAHCALRaw = 
	      dynamic_cast<const EVENT::LCGenericObject *const>(pLCCollection->getElementAt(e));
	  
	    const int nChannels = pAHCALRaw->getIntVal(NChannelsIndex);
	  
	    //---------------------------------------------------------------------------------------
	    for(int f=0; f<nChannels; f++ ) {
	      // Vectors for storing our TDC and ADC by channel
	    
	      int tdcRAW;
	      int adcRAW;
	      int tdc;
	      int adc;
	      int hitbit_tdc;
	      int gainbit_tdc;
	      int hitbit_adc;
	      int gainbit_adc;
	    
	      tdcRAW = pAHCALRaw->getIntVal(TDCFirstChannelIndex+f);
	      adcRAW = pAHCALRaw->getIntVal(ADCFirstChannelIndex+f);
	    
	      tdc = tdcRAW%4096;
	      adc = adcRAW%4096;
	    
	      hitbit_adc = (adcRAW & 0x1000)?1:0;
	      gainbit_adc = (adcRAW & 0x2000)?1:0;
	    
	      hitbit_tdc = (tdcRAW & 0x1000)?1:0;
	      gainbit_tdc = (tdcRAW & 0x2000)?1:0;
		  
	      if ( hitbit_adc == hitbit_tdc && pAHCALRaw->getIntVal(EvtNrIndex) !=0 && hitbit_adc == 1) {
		int ijk = electronicsToIJK(pAHCALRaw->getIntVal(ChipIDIndex),f);
		int I = ijk / 10000;
		int J = ( ijk  % 10000 ) /100;
		int K = ( ijk  % 10000 ) % 100;
		if(adc>300 ) {
		  m_pCorrelatedBXID->get<TH1I>()->Fill((TimeStamp_trig-TimeStamp_start)-pAHCALRaw->getIntVal(BxIDIndex)*4);
		  if( ((TimeStamp_trig-TimeStamp_start)-pAHCALRaw->getIntVal(BxIDIndex)*4)>50 && ((TimeStamp_trig-TimeStamp_start)-pAHCALRaw->getIntVal(BxIDIndex)*4)<62 ) {
		    for(int i=0; i< X_sensor0.size(); i++) {
		      if(K==1) m_pX_I_300_l01->get<TH2I>()->Fill(I,X_sensor0.at(i),adc);
		      if(K==2) m_pX_I_300_l02->get<TH2I>()->Fill(I,X_sensor0.at(i),adc);
		      if(K==3) m_pX_I_300_l03->get<TH2I>()->Fill(I,X_sensor0.at(i),adc);
		      if(K==4) m_pX_I_300_l04->get<TH2I>()->Fill(I,X_sensor0.at(i),adc);
		      if(K==5) m_pX_I_300_l05->get<TH2I>()->Fill(I,X_sensor0.at(i),adc);
		      if(K==6) m_pX_I_300_l06->get<TH2I>()->Fill(I,X_sensor0.at(i),adc);
		      
		      if(K==1) m_pX_J_300_l01->get<TH2I>()->Fill(J,X_sensor0.at(i),adc);
		      if(K==2) m_pX_J_300_l02->get<TH2I>()->Fill(J,X_sensor0.at(i),adc);
		      if(K==3) m_pX_J_300_l03->get<TH2I>()->Fill(J,X_sensor0.at(i),adc);
		      if(K==4) m_pX_J_300_l04->get<TH2I>()->Fill(J,X_sensor0.at(i),adc);
		      if(K==5) m_pX_J_300_l05->get<TH2I>()->Fill(J,X_sensor0.at(i),adc);
		      if(K==6) m_pX_J_300_l06->get<TH2I>()->Fill(J,X_sensor0.at(i),adc);
		    }
		    for(int i=0; i< Y_sensor0.size(); i++) {
		      if(K==1) m_pY_I_300_l01->get<TH2I>()->Fill(I,Y_sensor0.at(i),adc);
		      if(K==2) m_pY_I_300_l02->get<TH2I>()->Fill(I,Y_sensor0.at(i),adc);
		      if(K==3) m_pY_I_300_l03->get<TH2I>()->Fill(I,Y_sensor0.at(i),adc);
		      if(K==4) m_pY_I_300_l04->get<TH2I>()->Fill(I,Y_sensor0.at(i),adc);
		      if(K==5) m_pY_I_300_l05->get<TH2I>()->Fill(I,Y_sensor0.at(i),adc);
		      if(K==6) m_pY_I_300_l06->get<TH2I>()->Fill(I,Y_sensor0.at(i),adc);
		      
		      if(K==1) m_pY_J_300_l01->get<TH2I>()->Fill(J,Y_sensor0.at(i),adc);
		      if(K==2) m_pY_J_300_l02->get<TH2I>()->Fill(J,Y_sensor0.at(i),adc);
		      if(K==3) m_pY_J_300_l03->get<TH2I>()->Fill(J,Y_sensor0.at(i),adc);
		      if(K==4) m_pY_J_300_l04->get<TH2I>()->Fill(J,Y_sensor0.at(i),adc);
		      if(K==5) m_pY_J_300_l05->get<TH2I>()->Fill(J,Y_sensor0.at(i),adc);
		      if(K==6) m_pY_J_300_l06->get<TH2I>()->Fill(J,Y_sensor0.at(i),adc);
		    }
		  } else  {
		    for(int i=0; i< X_sensor0.size(); i++) {
		      if(K==1) m_pX_noC_I_300_l01->get<TH2I>()->Fill(I,X_sensor0.at(i),adc);
		      if(K==2) m_pX_noC_I_300_l02->get<TH2I>()->Fill(I,X_sensor0.at(i),adc);
		      if(K==3) m_pX_noC_I_300_l03->get<TH2I>()->Fill(I,X_sensor0.at(i),adc);
		      if(K==4) m_pX_noC_I_300_l04->get<TH2I>()->Fill(I,X_sensor0.at(i),adc);
		      if(K==5) m_pX_noC_I_300_l05->get<TH2I>()->Fill(I,X_sensor0.at(i),adc);
		      if(K==6) m_pX_noC_I_300_l06->get<TH2I>()->Fill(I,X_sensor0.at(i),adc);
		      
		      if(K==1) m_pX_noC_J_300_l01->get<TH2I>()->Fill(J,X_sensor0.at(i),adc);
		      if(K==2) m_pX_noC_J_300_l02->get<TH2I>()->Fill(J,X_sensor0.at(i),adc);
		      if(K==3) m_pX_noC_J_300_l03->get<TH2I>()->Fill(J,X_sensor0.at(i),adc);
		      if(K==4) m_pX_noC_J_300_l04->get<TH2I>()->Fill(J,X_sensor0.at(i),adc);
		      if(K==5) m_pX_noC_J_300_l05->get<TH2I>()->Fill(J,X_sensor0.at(i),adc);
		      if(K==6) m_pX_noC_J_300_l06->get<TH2I>()->Fill(J,X_sensor0.at(i),adc);
		    }
		    for(int i=0; i< Y_sensor0.size(); i++) {
		      if(K==1) m_pY_noC_I_300_l01->get<TH2I>()->Fill(I,Y_sensor0.at(i),adc);
		      if(K==2) m_pY_noC_I_300_l02->get<TH2I>()->Fill(I,Y_sensor0.at(i),adc);
		      if(K==3) m_pY_noC_I_300_l03->get<TH2I>()->Fill(I,Y_sensor0.at(i),adc);
		      if(K==4) m_pY_noC_I_300_l04->get<TH2I>()->Fill(I,Y_sensor0.at(i),adc);
		      if(K==5) m_pY_noC_I_300_l05->get<TH2I>()->Fill(I,Y_sensor0.at(i),adc);
		      if(K==6) m_pY_noC_I_300_l06->get<TH2I>()->Fill(I,Y_sensor0.at(i),adc);
		      
		      if(K==1) m_pY_noC_J_300_l01->get<TH2I>()->Fill(J,Y_sensor0.at(i),adc);
		      if(K==2) m_pY_noC_J_300_l02->get<TH2I>()->Fill(J,Y_sensor0.at(i),adc);
		      if(K==3) m_pY_noC_J_300_l03->get<TH2I>()->Fill(J,Y_sensor0.at(i),adc);
		      if(K==4) m_pY_noC_J_300_l04->get<TH2I>()->Fill(J,Y_sensor0.at(i),adc);
		      if(K==5) m_pY_noC_J_300_l05->get<TH2I>()->Fill(J,Y_sensor0.at(i),adc);
		      if(K==6) m_pY_noC_J_300_l06->get<TH2I>()->Fill(J,Y_sensor0.at(i),adc);
		    }
		  }
		}
	      }
	      //---------------------------------------------------------------------------------------
	    }		    
	  }//for elements

      }
      X_sensor0.clear();
      Y_sensor0.clear();
      
    }  

    return STATUS_CODE_SUCCESS;
    
  }
  
  //-------------------------------------------------------------------------------------------------

  StatusCode Correlations::startOfCycle()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- startOfCycle()" );
    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Correlations::endOfCycle()
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- endOfCycle()" );

    // run all quality tests on all monitor elements
    RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, DQMModuleApi::runQualityTests(this));

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Correlations::startOfRun(DQMRun *pRun)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- startOfRun()" );
    LOG4CXX_INFO( dqmMainLogger , "Run no " << pRun->getRunNumber() );
    //	time_t startTime = pRun->getStartTime();
    time_t startTime = std::chrono::system_clock::to_time_t(pRun->getStartTime());

    std::string timeStr;
    DQMCoreTool::timeToHMS(startTime, timeStr);

    goodDAQ = 0;
    badDAQ = 0;

    LOG4CXX_INFO( dqmMainLogger , "Start time " << timeStr );
    LOG4CXX_INFO( dqmMainLogger , "Detector is " << pRun->getDetectorName() );
    LOG4CXX_INFO( dqmMainLogger , "Description " << pRun->getDescription() );

    return STATUS_CODE_SUCCESS;
  }

  //-------------------------------------------------------------------------------------------------

  StatusCode Correlations::endOfRun(DQMRun *pRun)
  {
    LOG4CXX_INFO( dqmMainLogger , "Module : " << getName() << " -- endOfRun()" );
    LOG4CXX_INFO( dqmMainLogger , "Run no " << pRun->getRunNumber() );

    //	time_t endTime = pRun->getEndTime();
    time_t endTime = std::chrono::system_clock::to_time_t(pRun->getEndTime());
    std::string timeStr;
    DQMCoreTool::timeToHMS(endTime, timeStr);

    LOG4CXX_INFO( dqmMainLogger , "End time " << timeStr );

    return STATUS_CODE_SUCCESS;
  }


  StatusCode Correlations::buildGeometryMap(const TiXmlHandle xmlHandle)
  {

    LOG4CXX_INFO( dqmMainLogger , "Building geometry map..." );

    //Getting the very first child of the XML file; in our case, this is the dqm4hepGeometryMap bracket.
    const dqm4hep::TiXmlHandle xmlFileHandle(xmlHandle.FirstChildElement().Element());

    //Giving a unique name to the globalGeometryProperties object
    dqm4hep::TiXmlHandle pGlobalPropertiesXmlElement(xmlFileHandle.FirstChild("globalGeometryProperties").Element());

    //Iterate over each layer
    for (dqm4hep::TiXmlElement *pLayerXmlElement = xmlFileHandle.FirstChild("layer").Element(); NULL != pLayerXmlElement; pLayerXmlElement = pLayerXmlElement->NextSiblingElement("layer"))
      {

	dqm4hep::TiXmlHandle pLayerHandle(pLayerXmlElement);

	//Iterate over each chip
	for (dqm4hep::TiXmlElement *pChipXmlElement = pLayerHandle.FirstChild("chip").Element(); NULL != pChipXmlElement; pChipXmlElement = pChipXmlElement->NextSiblingElement("chip"))
	  {

	    dqm4hep::TiXmlHandle pChipHandle(pChipXmlElement);
	
	    //Iterate over each channel
	    for (dqm4hep::TiXmlElement *pChannelXmlElement = pChipHandle.FirstChild("channel").Element(); NULL != pChannelXmlElement; pChannelXmlElement = pChannelXmlElement->NextSiblingElement("channel"))
	      {

		int ChipID, ChannelID, I, J, K, ChpChnNum, ijkNum;

		//Pull out all the data: chip number, channel number, ijk
		pChipXmlElement->QueryValueAttribute<int>("id", &ChipID);
		pChannelXmlElement->QueryValueAttribute<int>("id", &ChannelID);
		pChannelXmlElement->QueryValueAttribute<int>("i", &I);
		pChannelXmlElement->QueryValueAttribute<int>("j", &J);
		pChannelXmlElement->QueryValueAttribute<int>("k", &K);

		//I = 13 - I; //uncomment for mirroring of I axis

		//Formatting data to go into our map
		ChpChnNum = ChipID*100+ChannelID;
		ijkNum = I*10000 + J*100 + K;


		//Filling the map (Chip, Chn)->(I, J, K)
		ijkmap.insert(std::make_pair(ChpChnNum, ijkNum));

		//Filling the map (I, J, K)->(Chip, Chn)
		chpchnmap.insert(std::make_pair(ijkNum, ChpChnNum));

	      }
	  }
      }

    std::cout<<chpchnmap.size()<<" "<< ijkmap.size()<<std::endl;

    LOG4CXX_INFO( dqmMainLogger , "Geometry map built successfully." );

    return STATUS_CODE_SUCCESS;

  }

  int Correlations::electronicsToIJK(int Chip, int Channel)
  {
    std::map<int, int>::iterator itMap;
    int index = Chip*100+Channel;
    int IJK = -1;
    // std::cout<<"electronicsToIJK "<<ijkmap.size()<<std::endl;
    //std::cout<<index<<" "<<Chip<<" "<<Channel<<std::endl;

    if(ijkmap.find(index) != ijkmap.end())
      {
	itMap = ijkmap.find(index);
	IJK = itMap->second;
	//	std::cout<<"find: "<<IJK<<std::endl;
      }

    return IJK;
  }

  int Correlations::IJKToElectronics(int I, int J, int K)
  {
    std::map<int, int>::iterator itMap;
    int index = I*10000+J*100+K;
    int ChipChn= -1;

    if(chpchnmap.find(index) != chpchnmap.end())
      {
	itMap = chpchnmap.find(index);
	ChipChn = itMap->second;
      }

    return ChipChn;
  }




  StatusCode Correlations::buildHotPixelsMap(const TiXmlHandle xmlHandle)
  {

    LOG4CXX_INFO( dqmMainLogger , "Building Hot Pixels map..." );

    //Getting the very first child of the XML file; in our case, this is the dqm4hepGeometryMap bracket.
    const dqm4hep::TiXmlHandle xmlFileHandle(xmlHandle.FirstChildElement().Element());

    //Iterate over each layer
    for (dqm4hep::TiXmlElement *pSensorXmlElement = xmlFileHandle.FirstChild("sensor").Element(); NULL != pSensorXmlElement; pSensorXmlElement = pSensorXmlElement->NextSiblingElement("sensor"))
      {

	dqm4hep::TiXmlHandle pSensorHandle(pSensorXmlElement);

	//Iterate over each pixel
	for (dqm4hep::TiXmlElement *pPixelXmlElement = pSensorHandle.FirstChild("pixel").Element(); NULL != pPixelXmlElement; pPixelXmlElement = pPixelXmlElement->NextSiblingElement("pixel"))
	  {

	    dqm4hep::TiXmlHandle pPixelHandle(pPixelXmlElement);

	    int SensorID, pixelX, pixelY;

	    //Pull out all the data: pixel number, channel number, ijk
	    pSensorXmlElement->QueryValueAttribute<int>("id", &SensorID);
	    pPixelXmlElement->QueryValueAttribute<int>("x", &pixelX);
	    pPixelXmlElement->QueryValueAttribute<int>("y", &pixelY);

	    if(SensorID==1) hotpixelsmap1.insert(std::make_pair(pixelX, pixelY));
	    if(SensorID==2) hotpixelsmap2.insert(std::make_pair(pixelX, pixelY));
	    if(SensorID==3) hotpixelsmap3.insert(std::make_pair(pixelX, pixelY));
	    if(SensorID==4) hotpixelsmap4.insert(std::make_pair(pixelX, pixelY));
	    if(SensorID==5) hotpixelsmap5.insert(std::make_pair(pixelX, pixelY));
	    if(SensorID==6) hotpixelsmap6.insert(std::make_pair(pixelX, pixelY));


	  }
	  
      }

    std::cout<<hotpixelsmap1.size()<<std::endl;
    std::cout<<hotpixelsmap2.size()<<std::endl;
    std::cout<<hotpixelsmap3.size()<<std::endl;
    std::cout<<hotpixelsmap4.size()<<std::endl;
    std::cout<<hotpixelsmap5.size()<<std::endl;
    std::cout<<hotpixelsmap6.size()<<std::endl;
    hotpixelsMap.push_back(hotpixelsmap1);
    hotpixelsMap.push_back(hotpixelsmap2);
    hotpixelsMap.push_back(hotpixelsmap3);
    hotpixelsMap.push_back(hotpixelsmap4);
    hotpixelsMap.push_back(hotpixelsmap5);
    hotpixelsMap.push_back(hotpixelsmap6);

    LOG4CXX_INFO( dqmMainLogger , "Geometry map built successfully." );

    return STATUS_CODE_SUCCESS;

  }

};

